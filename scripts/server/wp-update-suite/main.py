#!/usr/bin/env python3

import subprocess
import json
import sys
import os
import argparse
import re
from datetime import datetime
from typing import List, Dict, Optional
import logging
import logging.handlers
import tarfile
import shutil
from pathlib import Path
from typing import Any

# YAML parser preference: ruamel.yaml (preserve formatting) then PyYAML
try:
    from ruamel.yaml import YAML as RuamelYAML
    _yaml_type = 'ruamel'
except Exception:
    RuamelYAML = None
    try:
        import yaml as pyyaml
        _yaml_type = 'pyyaml'
    except Exception:
        pyyaml = None
        _yaml_type = None


logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)


def get_default_log_config() -> Dict[str, Any]:
    return {
        # Preferred: write logs into a directory (file name derived from base_filename)
        'log_dir': '/var/log',
        'base_filename': 'wp-update-suite.log',
        # Backward compatible: if log_file is provided in YAML, it will be honored
        'log_file': None,
        # When true, cChecking for and applying database schema updates...reate a unique active log file per script execution.
        # Example: wp-update-suite.20251212_095033_12345.log
        'per_run': False,
        # When true, redirect ALL stdout/stderr (including print output) into the log file
        # for the duration of the run, and remove console logging handlers.
        'redirect_stdio': False,
        'max_bytes': 10 * 1024 * 1024,  # 10MB
        'backup_count': 5,
        'log_level': 'INFO',
        'format': '%(asctime)s - %(levelname)s - %(message)s',
        'datefmt': None,
    }


def print_default_log_config_yaml() -> None:
    """Print a commented YAML template for log rotation configuration."""
    cfg = get_default_log_config()
    # Keep this output dependency-free (do not require PyYAML).
    print(
        "\n".join(
            [
                "# WordPress Update Suite Log Rotation Configuration",
                "# Generated by: --print-rotate-log-yaml",
                "#",
                "# Notes:",
                "# - Log lines are timestamped via the logging formatter.",
                "# - Rotation is size-based (max_bytes) with timestamped backup filenames.",
                "",
                "# Where to write logs (directory; filename derived from base_filename)",
                f"log_dir: {cfg['log_dir']}",
                f"base_filename: {cfg['base_filename']}",
                "",
                "# Backward compatible (optional): explicit full path (overrides log_dir/base_filename)",
                "# log_file: /var/log/wp-update-suite.log",
                "",
                "# Optional: create a unique active log file per run",
                f"per_run: {str(cfg['per_run']).lower()}",
                "",
                "# Optional: redirect stdout/stderr to the log file (useful for cron)",
                f"redirect_stdio: {str(cfg['redirect_stdio']).lower()}",
                "",
                "# Max log file size before rotating (bytes)",
                f"max_bytes: {cfg['max_bytes']}",
                "",
                "# Number of rotated log files to keep",
                f"backup_count: {cfg['backup_count']}",
                "",
                "# Log level: DEBUG, INFO, WARNING, ERROR, CRITICAL",
                f"log_level: {cfg['log_level']}",
                "",
                "# Log line format (includes timestamp via %(asctime)s)",
                f"format: '{cfg['format']}'",
                "",
                "# Optional: datetime formatting for %(asctime)s (Python strftime), e.g. '%Y-%m-%d %H:%M:%S'",
                "# datefmt: '%Y-%m-%d %H:%M:%S'",
            ]
        )
    )


def setup_log_rotation(*, rotate_logs: bool, config_path: Optional[str]) -> None:
    """Enable rotating file logging. If config_path is provided, it is loaded from YAML."""
    if not rotate_logs and not config_path:
        return

    log_config = get_default_log_config()

    # Load YAML config if provided
    if config_path:
        if not os.path.exists(config_path):
            print(f"âš ï¸  Log config file not found: {config_path} (using defaults)")
        else:
            try:
                if _yaml_type == 'ruamel' and RuamelYAML:
                    yaml = RuamelYAML()
                    loaded = yaml.load(Path(config_path))
                elif _yaml_type == 'pyyaml' and pyyaml:
                    with open(config_path, 'r') as f:
                        loaded = pyyaml.safe_load(f)
                else:
                    loaded = None

                if isinstance(loaded, dict):
                    log_config.update({k: v for k, v in loaded.items() if v is not None})
                elif loaded is not None:
                    print(f"âš ï¸  Log config YAML must be a mapping/dict: {config_path} (using defaults)")
            except Exception as e:
                print(f"âš ï¸  Failed to load log config YAML '{config_path}': {e} (using defaults)")

    explicit_log_file = log_config.get('log_file')
    log_dir = str(log_config.get('log_dir') or '/var/log')
    base_filename = str(log_config.get('base_filename') or 'wp-update-suite.log')
    per_run = bool(log_config.get('per_run') or False)
    redirect_stdio = bool(log_config.get('redirect_stdio') or False)

    if explicit_log_file:
        base_log_file = str(explicit_log_file)
    else:
        base_log_file = os.path.join(log_dir, base_filename)

    if per_run:
        p = Path(base_log_file)
        run_id = f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{os.getpid()}"
        # Preserve full suffix chain (e.g., .log, .log.txt)
        suffix = ''.join(p.suffixes)
        stem = p.name[:-len(suffix)] if suffix else p.name
        per_run_name = f"{stem}.{run_id}{suffix}" if suffix else f"{stem}.{run_id}"
        log_file = str(p.with_name(per_run_name))
    else:
        log_file = base_log_file

    max_bytes = int(log_config.get('max_bytes') or (10 * 1024 * 1024))
    backup_count = int(log_config.get('backup_count') or 5)
    fmt = str(log_config.get('format') or '%(asctime)s - %(levelname)s - %(message)s')
    datefmt = log_config.get('datefmt')
    level_name = str(log_config.get('log_level') or 'INFO').upper()

    level = getattr(logging, level_name, logging.INFO)
    logging.getLogger().setLevel(level)

    actual_log_dir = os.path.dirname(log_file)
    if actual_log_dir:
        os.makedirs(actual_log_dir, exist_ok=True)

    # If requested, ensure nothing is emitted to the terminal.
    # Note: stdout/stderr redirection happens after handler creation so any setup errors
    # can still be seen when running interactively.
    if redirect_stdio:
        root_logger = logging.getLogger()
        for h in list(root_logger.handlers):
            root_logger.removeHandler(h)

    handler = logging.handlers.RotatingFileHandler(
        log_file,
        maxBytes=max_bytes,
        backupCount=backup_count,
    )

    # Force timestamped rotated filenames (no numbered .1/.2 backups)
    # Example: wp-update-suite.log.20251212_143015
    def _timestamped_namer(default_name: str) -> str:
        base = log_file
        ts = datetime.now().strftime('%Y%m%d_%H%M%S')
        candidate = f"{base}.{ts}"
        # Avoid collisions if multiple rotations happen in the same second
        if not os.path.exists(candidate):
            return candidate
        for i in range(1, 1000):
            candidate_i = f"{base}.{ts}.{i}"
            if not os.path.exists(candidate_i):
                return candidate_i
        return f"{base}.{ts}.{os.getpid()}"

    handler.namer = _timestamped_namer

    handler.setLevel(level)
    handler.setFormatter(logging.Formatter(fmt=fmt, datefmt=datefmt))
    logging.getLogger().addHandler(handler)

    if redirect_stdio:
        class _PathWriter:
            def __init__(self, path: str):
                self._path = path

            def write(self, s: str) -> int:
                if not s:
                    return 0
                try:
                    with open(self._path, 'a', encoding='utf-8', errors='replace') as f:
                        f.write(s)
                    return len(s)
                except Exception:
                    return 0

            def flush(self) -> None:
                return

            def isatty(self) -> bool:
                return False

        sys.stdout = _PathWriter(log_file)
        sys.stderr = _PathWriter(log_file)

    logging.info(
        f"Log rotation enabled: file={log_file} max_bytes={max_bytes} backup_count={backup_count} per_run={per_run} redirect_stdio={redirect_stdio}"
    )

class WordPressUpdater:
    def __init__(self, container_name: Optional[str] = None, dry_run: bool = False, verbose: bool = False):
        self.container_name = container_name
        self.working_dir = None
        self.wp_containers = []
        self.dry_run = dry_run
        self.is_interactive = sys.stdin.isatty()
        self.verbose = verbose
        if self.verbose:
            logging.getLogger().setLevel(logging.DEBUG)

    def log(self, msg, level=logging.INFO):
        if self.verbose or level >= logging.INFO:
            logging.log(level, msg)

    def get_wp_containers(self) -> List[str]:
        self.log("Getting all Docker containers with names starting with 'wp_'", logging.DEBUG)
        try:
            result = subprocess.run(['docker', 'ps', '--format', '{{.Names}}'],
                                    capture_output=True, text=True, check=True)
            containers = [line.strip() for line in result.stdout.split('\n') if line.strip().startswith('wp_')]
            self.log(f"Found containers: {containers}", logging.DEBUG)
            return containers
        except subprocess.CalledProcessError as e:
            self.log(f"Error getting Docker containers: {e}", logging.ERROR)
            sys.exit(1)

    def get_working_directory(self, container_name: str) -> str:
        self.log(f"Getting working directory for container '{container_name}'", logging.DEBUG)
        """Get the working directory of a Docker container using docker inspect"""
        try:
            cmd = ['docker', 'inspect', container_name]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            inspect_data = json.loads(result.stdout)
            
            # Try to get working directory from labels first
            labels = inspect_data[0].get('Config', {}).get('Labels', {})
            working_dir = labels.get('com.docker.compose.project.working_dir')
            
            if not working_dir:
                # Fallback to container's working directory
                working_dir = inspect_data[0].get('Config', {}).get('WorkingDir')
                
            if not working_dir:
                print(f"âš ï¸  Could not determine working directory for container '{container_name}'")
                return None
                
            return working_dir
        except (subprocess.CalledProcessError, json.JSONDecodeError, KeyError) as e:
            print(f"âŒ Error getting working directory for '{container_name}': {e}")
            return None
    
    def docker_exec(self, container_name: str, command: List[str], docker_opts: List[str] = None) -> subprocess.CompletedProcess:
        self.log(f"Executing in container '{container_name}': {' '.join(command)}", logging.DEBUG)
        """Execute a command in a Docker container as root"""
        if docker_opts is None:
            docker_opts = []
        
        cmd = ['docker', 'exec', '-u', '0'] + docker_opts + [container_name] + command
        
        # The original implementation of dry run for this function was problematic
        # because it still executed the command. We will adjust it to only print.
        if self.dry_run and command[0] != 'wp':
             print(f"    ğŸ” DRY RUN: Would execute: {' '.join(cmd)}")
             # For non-wp commands in dry-run, return a dummy success object
             return subprocess.CompletedProcess(cmd, 0, stdout="", stderr="")

        # For wp-cli commands, we often need the output even in dry run for analysis.
        if self.dry_run and command[0] == 'wp':
            print(f"    ğŸ” DRY RUN (info gathering): Would execute: {' '.join(cmd)}")

        return subprocess.run(cmd, capture_output=True, text=True)
    
    def _elementor_installed(self, container_name: str) -> bool:
        """Return True if Elementor plugin appears installed in the container."""
        result = self.docker_exec(container_name, ['wp', '--allow-root', 'plugin', 'is-installed', 'elementor'])
        return result.returncode == 0

    def _check_or_update_elementor_db(self, container_name: str) -> str:
        """Check Elementor DB status by running the update command.

        Returns one of: 'not-installed', 'already-up-to-date', 'updated', 'failed'.

        Note: We intentionally run `wp elementor update db` because Elementor itself reports
        whether an update is needed. If it is already updated, this is a no-op.
        """
        if not self._elementor_installed(container_name):
            return 'not-installed'

        result = self.docker_exec(container_name, ['wp', '--allow-root', 'elementor', 'update', 'db'])
        output = ((result.stdout or '') + (result.stderr or '')).strip()
        if result.returncode == 0:
            if 'Success: The DB is already updated!' in output:
                return 'already-up-to-date'
            return 'updated'
        return 'failed'

    def get_wp_updates(self, container_name: str, *, check_elementor_db: bool = True) -> Dict:
        """Get available WordPress updates using WP CLI"""
        updates = {
            'core': None,
            'plugins': [],
            'themes': []
        }
        
        # Check core updates
        print(f"  ğŸ” Checking WordPress core updates...")
        result = self.docker_exec(container_name, ['wp', '--allow-root', 'core', 'check-update', '--format=json'])
        if result.returncode == 0 and result.stdout.strip():
            try:
                core_updates = json.loads(result.stdout)
                if core_updates:
                    updates['core'] = core_updates[0]
                    print(f"    ğŸ“¦ Core update available: {core_updates[0]['version']}")
                    if self.dry_run:
                        print(f"    ğŸ” DRY RUN: Would update WordPress core from current version to {core_updates[0]['version']}")
                else:
                    print(f"    âœ… WordPress core is up to date")
            except json.JSONDecodeError:
                print(f"    âš ï¸  Could not parse core update information")
        else:
            print(f"    âœ… WordPress core is up to date")
        
        # Check plugin updates
        print(f"  ğŸ” Checking plugin updates...")
        result = self.docker_exec(container_name, ['wp', '--allow-root', 'plugin', 'list', '--update=available', '--format=json'])
        if result.returncode == 0 and result.stdout.strip():
            try:
                plugin_updates = json.loads(result.stdout)
                updates['plugins'] = plugin_updates
                if plugin_updates:
                    print(f"    ğŸ“¦ {len(plugin_updates)} plugin(s) need updates:")
                    for i, plugin in enumerate(plugin_updates, 1):
                        print(f"      {i}. {plugin['name']} - {plugin['version']} â†’ {plugin['update_version']}")
                        if self.dry_run:
                            print(f"         ğŸ” DRY RUN: Would update plugin '{plugin['name']}' from {plugin['version']} to {plugin['update_version']}")
                else:
                    print(f"    âœ… All plugins are up to date")
                    # Explicitly confirm Elementor DB status (and update if needed)
                    if check_elementor_db:
                        if self.dry_run:
                            print(f"       ğŸ” DRY RUN: Would check whether Elementor database updates are needed")
                        else:
                            status = self._check_or_update_elementor_db(container_name)
                            if status == 'already-up-to-date':
                                print(f"       âœ… Elementor database is already up to date")
                                logging.info(
                                    f"Elementor database check: already up to date at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                                )
                            elif status == 'updated':
                                print(f"       ğŸ”„ Elementor database update applied")
                                logging.info(
                                    f"Elementor database update applied at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                                )
                            elif status == 'failed':
                                print(f"       âš ï¸  Elementor database update check failed")
                                logging.warning(
                                    f"Elementor database check/update failed at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                                )
            except json.JSONDecodeError:
                print(f"    âš ï¸  Could not parse plugin update information")
        else:
            print(f"    âœ… All plugins are up to date")
            if check_elementor_db:
                if self.dry_run:
                    print(f"       ğŸ” DRY RUN: Would check whether Elementor database updates are needed")
                else:
                    status = self._check_or_update_elementor_db(container_name)
                    if status == 'already-up-to-date':
                        print(f"       âœ… Elementor database is already up to date")
                        logging.info(
                            f"Elementor database check: already up to date at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                        )
                    elif status == 'updated':
                        print(f"       ğŸ”„ Elementor database update applied")
                        logging.info(
                            f"Elementor database update applied at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                        )
                    elif status == 'failed':
                        print(f"       âš ï¸  Elementor database update check failed")
                        logging.warning(
                            f"Elementor database check/update failed at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                        )
        
        # Check theme updates
        print(f"  ğŸ” Checking theme updates...")
        result = self.docker_exec(container_name, ['wp', '--allow-root', 'theme', 'list', '--update=available', '--format=json'])
        if result.returncode == 0 and result.stdout.strip():
            try:
                theme_updates = json.loads(result.stdout)
                updates['themes'] = theme_updates
                if theme_updates:
                    print(f"    ğŸ“¦ {len(theme_updates)} theme(s) need updates:")
                    for i, theme in enumerate(theme_updates, 1):
                        print(f"      {i}. {theme['name']} - {theme['version']} â†’ {theme['update_version']}")
                        if self.dry_run:
                            print(f"         ğŸ” DRY RUN: Would update theme '{theme['name']}' from {theme['version']} to {theme['update_version']}")
                else:
                    print(f"    âœ… All themes are up to date")
            except json.JSONDecodeError:
                print(f"    âš ï¸  Could not parse theme update information")
        else:
            print(f"    âœ… All themes are up to date")
        
        return updates
    
    def parse_selection(self, selection: str, max_items: int) -> List[int]:
        """Parse user selection string (e.g., '1,3,5-7' or '1|3|7')"""
        if not selection or selection.lower() in ['none', 'skip']:
            return []
        
        if selection.lower() == 'all':
            return list(range(1, max_items + 1))
        
        indices = []
        # Handle both comma and pipe separators
        parts = re.split(r'[,|]', selection.strip())
        
        for part in parts:
            part = part.strip()
            if '-' in part:
                # Handle ranges like '1-5'
                try:
                    start, end = map(int, part.split('-'))
                    indices.extend(range(start, end + 1))
                except ValueError:
                    print(f"âš ï¸  Invalid range format: {part}")
            else:
                # Handle single numbers
                try:
                    indices.append(int(part))
                except ValueError:
                    # Might be a slug name
                    indices.append(part)
        
        return indices
    
    def get_site_url(self, container_name: str) -> Optional[str]:
        """Extract WP_HOME or site URL from container env."""
        try:
            cmd = ['docker', 'inspect', container_name]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            inspect_data = json.loads(result.stdout)
            envs = inspect_data[0].get('Config', {}).get('Env', [])
            for env_var in envs:
                if env_var.startswith('WP_HOME='):
                    return env_var.split('=', 1)[1].replace('https://', '').replace('http://', '').strip('/')
        except Exception as e:
            print(f"âš ï¸  Could not extract site URL: {e}")
        return None

    def backup_site(self, container_name: str, working_dir: str, delete_tarballs_in_container: bool = False) -> bool:
        self.log(f"Starting backup for container '{container_name}' in '{working_dir}'", logging.INFO)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        site_url = self.get_site_url(container_name) or container_name.replace('wp_', '')
        backup_dir = f"/var/opt/{site_url}/www/backups"
        db_backup_file = f"wp_backup_{container_name}_{timestamp}.sql"

        if self.dry_run:
            self.log(f"  ğŸ” DRY RUN: Would create backup for '{container_name}'...")
            self.log(f"    ğŸ” DRY RUN: Would create backup directory: {backup_dir}")
            self.log(f"    ğŸ” DRY RUN: Would export database to: {backup_dir}/{db_backup_file}")
            self.log(f"    ğŸ” DRY RUN: Backup would be created successfully")
            return True

        self.log(f"  ğŸ’¾ Creating backup for '{container_name}'...")

        # Ensure backup directory exists on the host
        try:
            os.makedirs(backup_dir, exist_ok=True)
        except Exception as e:
            self.log(f"    âŒ Failed to create backup directory '{backup_dir}': {e}")
            return False

        # Also ensure the directory exists inside the container
        mkdir_cmd = ['docker', 'exec', '-u', '0', container_name, 'mkdir', '-p', backup_dir]
        subprocess.run(mkdir_cmd, capture_output=True)

        # Backup database
        self.log(f"    ğŸ—„ï¸  Exporting database...", logging.INFO)
        db_path = f"{backup_dir}/{db_backup_file}"
        result = self.docker_exec(container_name, ['wp', '--allow-root', 'db', 'export', db_path])
        if result.returncode != 0:
            self.log(f"    âŒ Database backup failed: {result.stderr}", logging.ERROR)
            return False

        self.log(f"Backup created: {db_path}", logging.INFO)
        logging.info(f"Backup task completed successfully at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        return True

    def update_wordpress_core(self, container_name: str) -> bool:
        """Update WordPress core"""
        if self.dry_run:
            print(f"    ğŸ” DRY RUN: Would update WordPress core...")
            print(f"    ğŸ” DRY RUN: Would execute: docker exec -u 0 {container_name} wp --allow-root core update")
            print(f"    ğŸ” DRY RUN: WordPress core would be updated successfully")
            return True
            
        # Prefer to perform a core update by updating the image referenced in docker-compose.yml
        # and performing a docker compose pull/down/up if a compose file exists in the working dir
        compose_result = self.update_core_via_compose(self.working_dir, container_name)
        if compose_result is not None:
            return compose_result

        # Fallback to WP CLI core update when no compose-based update was performed
        print(f"    ğŸ”„ Updating WordPress core (wp-cli)...")
        result = self.docker_exec(container_name, ['wp', '--allow-root', 'core', 'update'])
        if result.returncode == 0:
            print(f"    âœ… WordPress core updated successfully")
            logging.info(f"WordPress core update task completed successfully at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            return True
        else:
            print(f"    âŒ WordPress core update failed: {result.stderr}")
            return False

    def locate_compose_file(self, working_dir: str) -> Optional[str]:
        """Locate docker-compose file(s) in the provided working directory."""
        if not working_dir:
            return None
        candidates = [
            'docker-compose.yml', 'docker-compose.yaml',
            'compose.yml', 'compose.yaml'
        ]
        for c in candidates:
            p = Path(working_dir) / c
            if p.exists():
                return str(p)
        return None

    def update_compose_image_if_needed(self, compose_path: str, service_name: Optional[str] = None) -> bool:
        """Update the service image to ghcr.io/ciwebgroup/advanced-wordpress:latest if necessary.
        Returns True if a change was made, False otherwise.
        """
        desired_image = 'ghcr.io/ciwebgroup/advanced-wordpress:latest'
        try:
            if _yaml_type == 'ruamel' and RuamelYAML:
                yaml = RuamelYAML()
                data = yaml.load(Path(compose_path))
                services = data.get('services') or {}
                # Determine candidate service
                svc = None
                if service_name and service_name in services:
                    svc = service_name
                else:
                    for s in services:
                        if s.startswith('wp_'):
                            svc = s
                            break
                if not svc:
                    return False
                image_val = services[svc].get('image')
                if image_val != desired_image:
                    services[svc]['image'] = desired_image
                    yaml.dump(data, Path(compose_path))
                    return True
                return False
            elif _yaml_type == 'pyyaml' and pyyaml:
                with open(compose_path, 'r') as f:
                    data = pyyaml.safe_load(f)
                services = data.get('services') or {}
                svc = None
                if service_name and service_name in services:
                    svc = service_name
                else:
                    for s in services:
                        if s.startswith('wp_'):
                            svc = s
                            break
                if not svc:
                    return False
                image_val = services[svc].get('image')
                if image_val != desired_image:
                    services[svc]['image'] = desired_image
                    with open(compose_path, 'w') as f:
                        pyyaml.safe_dump(data, f, default_flow_style=False)
                    return True
                return False
            else:
                print('    âš ï¸  No YAML parser available (ruamel.yaml or PyYAML). Skipping compose image check.')
                return False
        except Exception as e:
            print(f"    âš ï¸  Error reading/updating compose file '{compose_path}': {e}")
            return False

    def _run_compose_commands(self, working_dir: str) -> bool:
        """Executes: docker compose pull && docker compose down && docker compose up -d
        Returns True on success, False otherwise.
        Tries 'docker compose' first and falls back to 'docker-compose'."""
        if not working_dir:
            return False
        commands = [
            (['docker', 'compose', 'pull'], 'docker compose pull'),
            (['docker', 'compose', 'down'], 'docker compose down'),
            (['docker', 'compose', 'up', '-d'], 'docker compose up -d')
        ]
        # Try docker compose commands (compose v2), fall back to docker-compose if any command fails
        for cmd, _desc in commands:
            result = subprocess.run(cmd, cwd=working_dir, capture_output=True, text=True)
            if result.returncode != 0:
                # Try docker-compose variant for this command
                alt_cmd = cmd[:]
                alt_cmd[0] = 'docker-compose'
                result_alt = subprocess.run(alt_cmd, cwd=working_dir, capture_output=True, text=True)
                if result_alt.returncode != 0:
                    print(f"  âŒ Command failed in {working_dir}: {cmd if result.returncode != 0 else alt_cmd}")
                    print(f"    stderr: {result.stderr if result.returncode != 0 else result_alt.stderr}")
                    return False
        return True

    def update_core_via_compose(self, working_dir: str, container_name: str) -> Optional[bool]:
        """If a compose file exists for the working_dir and references the container/service, update image if needed and run compose commands.
        Returns True if compose-based update was performed successfully, False if attempted and failed, or None if not attempted (no compose file/service found).
        """
        compose_path = self.locate_compose_file(working_dir)
        if not compose_path:
            return None

        # Attempt to use service name matching the container name first
        service_name = None
        try:
            # If a service exactly matches the container name, use it
            if _yaml_type == 'ruamel' and RuamelYAML:
                yaml = RuamelYAML()
                data = yaml.load(Path(compose_path))
            elif _yaml_type == 'pyyaml' and pyyaml:
                with open(compose_path, 'r') as f:
                    data = pyyaml.safe_load(f)
            else:
                data = {}
        except Exception:
            data = {}
        services = (data or {}).get('services') or {}
        if container_name in services:
            service_name = container_name
        else:
            # Otherwise take the first wp_ service that matches the container pattern
            for s in services:
                if s.startswith('wp_'):
                    service_name = s
                    break

        if not service_name:
            # No wp_* service found in compose file
            return None

        # Update image in compose file if needed
        changed = self.update_compose_image_if_needed(compose_path, service_name=service_name)
        if changed:
            print(f"    âœ… Updated service '{service_name}' image in compose file to ghcr.io/ciwebgroup/advanced-wordpress:latest")
        else:
            print(f"    â„¹ï¸ Compose image already up-to-date for service '{service_name}'")

        print(f"    ğŸ”„ Running docker compose pull/down/up in '{working_dir}' to apply image changes")
        success = self._run_compose_commands(working_dir)
        if success:
            print(f"    âœ… Compose-based core update performed successfully for '{service_name}'")
            logging.info(f"Compose-based core update task completed successfully at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            return True
        else:
            print(f"    âŒ Compose-based core update failed for '{service_name}'")
            return False
    
    def update_plugins(self, container_name: str, plugins: List, selected_indices: List) -> bool:
        """Update selected plugins"""
        if self.dry_run:
            print(f"    ğŸ” DRY RUN: Would update selected plugins...")
            for idx in selected_indices:
                if isinstance(idx, int) and 1 <= idx <= len(plugins):
                    plugin = plugins[idx - 1]
                    plugin_name = plugin['name']
                    plugin_title = plugin.get('title', plugin_name)
                    current_version = plugin.get('version', 'unknown')
                    new_version = plugin.get('update_version', 'latest')
                elif isinstance(idx, str):
                    plugin_name = idx
                    plugin_title = idx
                    current_version = 'current'
                    new_version = 'latest'
                else:
                    print(f"    ğŸ” DRY RUN: Would skip invalid plugin selection: {idx}")
                    continue
                
                print(f"    ğŸ” DRY RUN: Would update plugin '{plugin_name}' ({plugin_title})")
                print(f"       ğŸ” DRY RUN: Would execute: docker exec -u 0 {container_name} wp --allow-root plugin update {plugin_name}")
                print(f"       ğŸ” DRY RUN: Plugin '{plugin_name}' would be updated from {current_version} to {new_version}")
            print(f"    ğŸ” DRY RUN: All selected plugins would be updated successfully")
            return True
        
        success = True
        for idx in selected_indices:
            if isinstance(idx, int) and 1 <= idx <= len(plugins):
                plugin = plugins[idx - 1]
                plugin_name = plugin['name']
            elif isinstance(idx, str):
                # Assume it's a plugin slug
                plugin_name = idx
            else:
                print(f"    âš ï¸  Invalid plugin selection: {idx}")
                continue
            
            print(f"    ğŸ”„ Updating plugin '{plugin_name}'...")
            result = self.docker_exec(container_name, ['wp', '--allow-root', 'plugin', 'update', plugin_name])
            if result.returncode == 0:
                print(f"    âœ… Plugin '{plugin_name}' updated successfully")
            else:
                print(f"    âŒ Plugin '{plugin_name}' update failed: {result.stderr}")
                success = False
        
        # Flush cache after all plugin updates
        print(f"    ğŸ”„ Flushing cache...")
        result = self.docker_exec(container_name, ['wp', '--allow-root', 'cache', 'flush'])
        if result.returncode == 0:
            print(f"    âœ… Cache flushed successfully")
            logging.info(f"Plugin updates and cache flush task completed successfully at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        else:
            print(f"    âŒ Cache flush failed: {result.stderr}")
        
        return success
    
    def update_themes(self, container_name: str, themes: List, selected_indices: List) -> bool:
        """Update selected themes"""
        if self.dry_run:
            print(f"    ğŸ” DRY RUN: Would update selected themes...")
            for idx in selected_indices:
                if isinstance(idx, int) and 1 <= idx <= len(themes):
                    theme = themes[idx - 1]
                    theme_name = theme['name']
                    theme_title = theme.get('title', theme_name)
                    current_version = theme.get('version', 'unknown')
                    new_version = theme.get('update_version', 'latest')
                elif isinstance(idx, str):
                    theme_name = idx
                    theme_title = idx
                    current_version = 'current'
                    new_version = 'latest'
                else:
                    print(f"    ğŸ” DRY RUN: Would skip invalid theme selection: {idx}")
                    continue
                
                print(f"    ğŸ” DRY RUN: Would update theme '{theme_name}' ({theme_title})")
                print(f"       ğŸ” DRY RUN: Would execute: docker exec -u 0 {container_name} wp --allow-root theme update {theme_name}")
                print(f"       ğŸ” DRY RUN: Theme '{theme_name}' would be updated from {current_version} to {new_version}")
            print(f"    ğŸ” DRY RUN: All selected themes would be updated successfully")
            return True
        
        success = True
        for idx in selected_indices:
            if isinstance(idx, int) and 1 <= idx <= len(themes):
                theme = themes[idx - 1]
                theme_name = theme['name']
            elif isinstance(idx, str):
                # Assume it's a theme slug
                theme_name = idx
            else:
                print(f"    âš ï¸  Invalid theme selection: {idx}")
                continue
            
            print(f"    ğŸ”„ Updating theme '{theme_name}'...")
            result = self.docker_exec(container_name, ['wp', '--allow-root', 'theme', 'update', theme_name])
            if result.returncode == 0:
                print(f"    âœ… Theme '{theme_name}' updated successfully")
            else:
                print(f"    âŒ Theme '{theme_name}' update failed: {result.stderr}")
                success = False
        
        if success:
            logging.info(f"Theme updates task completed successfully at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        return success
    
    def update_db_schema(self, container_name: str) -> bool:
        """Run `wp core update-db` to apply any pending database schema updates."""
        if self.dry_run:
            print(f"    ğŸ” DRY RUN: Would check for and apply database schema updates...")
            print(f"    ğŸ” DRY RUN: Would execute: docker exec -u 0 {container_name} wp --allow-root core update-db")
            print(f"    ğŸ” DRY RUN: Database schema check/update would be performed.")
            return True

        print(f"    ğŸ”„ Checking for and applying database schema updates...")
        result = self.docker_exec(container_name, ['wp', '--allow-root', 'core', 'update-db'])
        stdout = (result.stdout or '').strip()
        stderr = (result.stderr or '').strip()
        combined = "\n".join([s for s in [stdout, stderr] if s]).strip()
        combined_lower = combined.lower()

        # WP-CLI sometimes emits benign PHP warnings on stderr even when the command succeeds.
        # We only consider it a failure if there are strong error indicators.
        strong_error_tokens = [
            'php fatal error',
            'fatal error',
            'uncaught',
            'exception',
            'error:',
            'failed opening required',
            'failed to open stream',
            'no such file or directory',
            'wp-settings.php',
        ]
        has_strong_error = any(t in combined_lower for t in strong_error_tokens)

        success_phrases = [
            'success: wordpress database already at latest db version',
            'success: wordpress database upgraded successfully',
            'success: wordpress database updated successfully',
        ]
        has_success_phrase = any(p in combined_lower for p in success_phrases)

        succeeded = (result.returncode == 0 and not has_strong_error) or (has_success_phrase and not has_strong_error)

        if succeeded:
            print(f"    âœ… Database schema check/update completed.")
            if 'already at latest db version' in combined_lower or 'already updated' in combined_lower or 'already up to date' in combined_lower:
                print(f"       â„¹ï¸ Database schema is already up to date")
            else:
                # Only print stdout if it contains something other than the common no-op status.
                if stdout:
                    print(f"       Output: {stdout}")

            if stderr and ('warning' in stderr.lower() or 'deprecated' in stderr.lower()) and not has_strong_error:
                print(f"       âš ï¸ WP-CLI emitted warnings; see log for details")
                logging.warning(
                    f"Database schema update completed with warnings at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}: {stderr[:2000]}"
                )

            logging.info(f"Database schema update task completed successfully at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            return True

        err_text = combined or stderr or stdout or f"nonzero exit code: {result.returncode}"
        if len(err_text) > 2000:
            err_text = err_text[:2000] + "... (truncated)"
        print(f"    âŒ Database schema update failed: {err_text}")
        logging.error(
            f"Database schema update failed at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} rc={result.returncode} output={err_text}"
        )
        return False

    def update_rank_math_elementor_plugins(self, container_name: str, plugins: list) -> bool:
        """
        Update Rank Math and Elementor plugins in the required order if present.
        Order: seo-by-rank-math, seo-by-rank-math-pro, elementor, elementor-pro
        """
        plugin_order = [
            "seo-by-rank-math",
            "seo-by-rank-math-pro",
            "elementor",
            "elementor-pro"
        ]
        inventory = self._generate_inventory(container_name, 'plugin') or []
        installed_slugs = {pl.get('name') for pl in inventory if isinstance(pl, dict) and pl.get('name')}

        # Plugins that both exist in the environment and have an available update
        found_plugins = [p for p in plugin_order if any(pl['name'] == p for pl in plugins)]
        # Plugins that are present but do not currently have an available update
        present_but_no_update = [p for p in plugin_order if p in installed_slugs and p not in found_plugins]

        if not found_plugins and not present_but_no_update:
            print(f"    â„¹ï¸ No Rank Math or Elementor plugins found; skipping related updates.")
            return True  # Nothing to do

        if not found_plugins and present_but_no_update:
            print(f"    â„¹ï¸ Rank Math/Elementor plugins are installed but already up to date; no ordered updates needed.")
            return True

        print(f"\nğŸ”„ Updating Rank Math and Elementor plugins in required order:")
        success = True
        for plugin_slug in found_plugins:
            print(f"    ğŸ”„ Updating '{plugin_slug}'...")
            result = self.docker_exec(container_name, ['wp', '--allow-root', 'plugin', 'update', plugin_slug])
            if result.returncode == 0:
                print(f"    âœ… Plugin '{plugin_slug}' updated successfully")
            else:
                print(f"    âŒ Plugin '{plugin_slug}' update failed: {result.stderr}")
                success = False
        
        # Update Elementor database if Elementor plugins were updated
        if any('elementor' in p for p in found_plugins):
            print(f"    ğŸ”„ Updating Elementor database...")
            result = self.docker_exec(container_name, ['wp', '--allow-root', 'elementor', 'update', 'db'])
            output = ((result.stdout or '') + (result.stderr or '')).strip()
            if result.returncode == 0:
                if 'Success: The DB is already updated!' in output:
                    print(f"    âœ… Elementor database is already up to date")
                    logging.info(
                        f"Elementor database check: already up to date at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                    )
                else:
                    print(f"    âœ… Elementor database updated successfully")
                    logging.info(
                        f"Elementor database update applied at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
                    )
            else:
                print(f"    âŒ Elementor database update failed: {result.stderr}")
                success = False
        else:
            print(f"    â„¹ï¸ No Elementor plugin updates detected; skipping Elementor database update.")
        
        if success:
            logging.info(f"Rank Math and Elementor plugins update task completed successfully at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        return success

    def print_dry_run_summary(self, selected_container: str, updates: Dict, 
                            update_core: bool = None, update_plugins: str = None, 
                            update_themes: str = None, backup: bool = True,
                            check_db_schema: bool = False):
        """Print a comprehensive summary of what would happen in dry run mode"""
        if not self.dry_run:
            return
            
        print(f"\n" + "="*80)
        print(f"ğŸ” DRY RUN SUMMARY - No changes will be made")
        print(f"="*80)
        print(f"Container: {selected_container}")
        print(f"Working Directory: {self.working_dir}")
        print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        action_count = 0
        
        # Backup actions
        if backup:
            action_count += 1
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            print(f"\n{action_count}. BACKUP CREATION:")
            print(f"   ğŸ“ Create backup directory: {self.working_dir}/backups")
            print(f"   ğŸ—„ï¸  Export database: wp_backup_{selected_container}_{timestamp}.sql")
            print(f"   ğŸ“¦ Create tarball: wp_backup_{selected_container}_{timestamp}.tar.gz")
        
        # Core update actions
        if update_core is not None:
            if update_core and updates['core']:
                action_count += 1
                core_info = updates['core']
                print(f"\n{action_count}. WORDPRESS CORE UPDATE:")
                print(f"   ğŸ¯ Target: WordPress Core")
                print(f"   ğŸ“¦ New Version: {core_info['version']}")
                print(f"   ğŸ’» Command: docker exec -u 0 {selected_container} wp --allow-root core update")
            elif update_core and not updates['core']:
                print(f"\nâŒ WORDPRESS CORE: No updates available")
        
        # Plugin update actions
        if update_plugins:
            if updates['plugins']:
                selected_plugins = self.parse_selection(update_plugins, len(updates['plugins']))
                if selected_plugins:
                    action_count += 1
                    print(f"\n{action_count}. PLUGIN UPDATES:")
                    for idx in selected_plugins:
                        if isinstance(idx, int) and 1 <= idx <= len(updates['plugins']):
                            plugin = updates['plugins'][idx - 1]
                            print(f"   ğŸ”Œ Plugin: {plugin['name']}")
                            print(f"      ğŸ“¦ Version: {plugin['version']} â†’ {plugin['update_version']}")
                            print(f"      ğŸ’» Command: docker exec -u 0 {selected_container} wp --allow-root plugin update {plugin['name']}")
                        elif isinstance(idx, str):
                            print(f"   ğŸ”Œ Plugin: {idx} (by slug)")
                            print(f"      ğŸ’» Command: docker exec -u 0 {selected_container} wp --allow-root plugin update {idx}")
            else:
                print(f"\nâŒ PLUGINS: No updates available")
        
        # Theme update actions
        if update_themes:
            if updates['themes']:
                selected_themes = self.parse_selection(update_themes, len(updates['themes']))
                if selected_themes:
                    action_count += 1
                    print(f"\n{action_count}. THEME UPDATES:")
                    for idx in selected_themes:
                        if isinstance(idx, int) and 1 <= idx <= len(updates['themes']):
                            theme = updates['themes'][idx - 1]
                            print(f"   ğŸ¨ Theme: {theme['name']}")
                            print(f"      ğŸ“¦ Version: {theme['version']} â†’ {theme['update_version']}")
                            print(f"      ğŸ’» Command: docker exec -u 0 {selected_container} wp --allow-root theme update {theme['name']}")
                        elif isinstance(idx, str):
                            print(f"   ğŸ¨ Theme: {idx} (by slug)")
                            print(f"      ğŸ’» Command: docker exec -u 0 {selected_container} wp --allow-root theme update {idx}")
            else:
                print(f"\nâŒ THEMES: No updates available")
        
        # DB Schema update actions
        if check_db_schema:
            action_count += 1
            print(f"\n{action_count}. DATABASE SCHEMA UPDATE:")
            print(f"   ğŸ¯ Target: WordPress Database Schema")
            print(f"   ğŸ’» Command: docker exec -u 0 {selected_container} wp --allow-root core update-db")

        if action_count == 0:
            print(f"\nâœ… No actions would be performed - everything is up to date")
        
        print(f"\n" + "="*80)
        print(f"ğŸ” End of dry run summary - {action_count} action(s) would be performed")
        print(f"ğŸ’¡ Run without --dry-run to execute these changes")
        print(f"="*80)
    
    def safe_input(self, prompt: str, default: str = "") -> str:
        """Safely get user input, handling non-interactive environments"""
        if not self.is_interactive:
            print(f"{prompt}[non-interactive, using default: {default}]")
            return default
        
        try:
            return input(prompt)
        except (EOFError, KeyboardInterrupt):
            print(f"\n[interrupted, using default: {default}]")
            return default
    
    def run_interactive(self, skip_rank_math_elementor_update=False, restart_docker=False, mirror_assets=False, check_db_schema=False):
        """Run the updater in interactive mode"""
        if self.dry_run:
            print("ğŸ” DRY RUN MODE: No changes will be made - showing what would happen")
        
        # Get all WordPress containers
        self.wp_containers = self.get_wp_containers()
        
        if not self.wp_containers:
            print("âŒ No WordPress Docker containers found with 'wp_' prefix.")
            sys.exit(1)
        
        # Select container
        selected_container = None
        if self.container_name:
            if self.container_name not in self.wp_containers:
                print(f"âŒ Container '{self.container_name}' not found.")
                sys.exit(1)
            selected_container = self.container_name
        else:
            # Check if we can run interactively for container selection
            if not self.is_interactive:
                print("âŒ Container selection requires interactive mode or --container-name parameter")
                print("Available containers:")
                for i, container in enumerate(self.wp_containers, 1):
                    print(f"  {i}. {container}")
                print("Use --container-name <name> to specify a container")
                sys.exit(1)
            
            print(f"ğŸ“¦ Found WordPress containers:")
            for i, container in enumerate(self.wp_containers, 1):
                print(f"  {i}. {container}")
            
            while True:
                try:
                    prompt_text = "\nSelect container number: "
                    choice = self.safe_input(prompt_text, "1")
                    if not choice:  # Handle empty input in non-interactive mode
                        choice = "1"
                    idx = int(choice) - 1
                    if 0 <= idx < len(self.wp_containers):
                        selected_container = self.wp_containers[idx]
                        break
                    else:
                        print("Please enter a valid number.")
                except (ValueError, IndexError):
                    print("Please enter a valid number.")
                    if not self.is_interactive:
                        print("Using first container as default")
                        selected_container = self.wp_containers[0]
                        break
        
        print(f"\nğŸ¯ Processing container: '{selected_container}'")
        
        # Get working directory
        self.working_dir = self.get_working_directory(selected_container)
        if not self.working_dir:
            sys.exit(1)
        
        print(f"ğŸ“ Working directory: {self.working_dir}")
        
        # Check for updates
        print(f"\nğŸ” Checking for available updates...")
        updates = self.get_wp_updates(selected_container, check_elementor_db=not skip_rank_math_elementor_update)

        # --- NEW: Update Rank Math and Elementor plugins first ---
        if updates['plugins'] and not skip_rank_math_elementor_update:
            self.update_rank_math_elementor_plugins(selected_container, updates['plugins'])
        # --- END NEW ---

        # Check if any updates are available
        has_updates = (updates['core'] is not None or 
                      len(updates['plugins']) > 0 or 
                      len(updates['themes']) > 0)
        
        if not has_updates:
            print(f"\nâœ… No updates available for '{selected_container}'")
            if self.dry_run:
                print(f"ğŸ” DRY RUN: No actions would be performed")
            return
        
        # Variables to track user choices for dry run summary
        will_backup = True
        will_update_core = False
        will_update_plugins = None
        will_update_themes = None
        
        # Ask for confirmation to proceed
        if self.dry_run:
            print(f"\nğŸ” DRY RUN: Simulating user confirmation for backup and updates...")
            proceed = True
        elif not self.is_interactive:
            print(f"\nğŸ” Non-interactive mode: Proceeding with updates (use --non-interactive for full automation)")
            proceed = True
        else:
            proceed_input = self.safe_input("\nâ“ Do you want to create a backup and proceed with updates? (y/N): ", "n")
            proceed = proceed_input.lower() in ['y', 'yes']
        
        if not proceed:
            print("âŒ Update cancelled by user.")
            if self.dry_run:
                print("ğŸ” DRY RUN: No actions would be performed")
            return
        
        # Create backup
        print(f"\nğŸ’¾ Creating backup...")
        if not self.backup_site(selected_container, self.working_dir):
            if not self.dry_run:
                print("âŒ Backup failed. Aborting updates.")
                return
        
        # Handle core updates
        if updates['core']:
            if self.dry_run:
                print(f"\nğŸ” DRY RUN: Simulating core update prompt...")
                will_update_core = True
            elif not self.is_interactive:
                print(f"\nğŸ” Non-interactive mode: Skipping core update (use --update-core flag)")
                will_update_core = False
            else:
                core_input = self.safe_input(f"\nâ“ Update WordPress core to {updates['core']['version']}? (y/N): ", "n")
                will_update_core = core_input.lower() in ['y', 'yes']
            
            if will_update_core:
                self.update_wordpress_core(selected_container)
        
        # Handle plugin updates
        if updates['plugins']:
            if self.dry_run:
                print(f"\nğŸ” DRY RUN: Simulating plugin update selection...")
                will_update_plugins = "all"  # Simulate selecting all for dry run
            elif not self.is_interactive:
                print(f"\nğŸ” Non-interactive mode: Skipping plugin updates (use --update-plugins flag)")
                will_update_plugins = None
            else:
                will_update_plugins = self.safe_input("\nâ“ Which plugins to update? (all/none/1,3,5/1-5/plugin-slug): ", "none")
            
            if will_update_plugins and will_update_plugins.lower() not in ['none', 'skip']:
                selected_plugins = self.parse_selection(will_update_plugins, len(updates['plugins']))
                if selected_plugins:
                    print(f"\nğŸ”„ Updating selected plugins...")
                    self.update_plugins(selected_container, updates['plugins'], selected_plugins)
        
        # Handle theme updates
        if updates['themes']:
            if self.dry_run:
                print(f"\nğŸ” DRY RUN: Simulating theme update selection...")
                will_update_themes = "all"  # Simulate selecting all for dry run
            elif not self.is_interactive:
                print(f"\nğŸ” Non-interactive mode: Skipping theme updates (use --update-themes flag)")
                will_update_themes = None
            else:
                will_update_themes = self.safe_input("\nâ“ Which themes to update? (all/none/1,3,5/1-5/theme-slug): ", "none")
            
            if will_update_themes and will_update_themes.lower() not in ['none', 'skip']:
                selected_themes = self.parse_selection(will_update_themes, len(updates['themes']))
                if selected_themes:
                    print(f"\nğŸ”„ Updating selected themes...")
                    self.update_themes(selected_container, updates['themes'], selected_themes)
        
        # Handle DB schema update
        if check_db_schema:
            print(f"\nğŸ”„ Checking/updating database schema...")
            self.update_db_schema(selected_container)

        if self.dry_run:
            self.print_dry_run_summary(selected_container, updates, will_update_core, 
                                     will_update_plugins, will_update_themes, will_backup,
                                     check_db_schema=check_db_schema)
        else:
            print(f"\nâœ… Update process completed for '{selected_container}'")
            if mirror_assets:
                self.mirror_wp_assets(selected_container)
            if restart_docker:
                self.restart_docker_compose(self.working_dir)

    def run_non_interactive(self, update_core: bool, update_plugins: str, update_themes: str, 
                          backup: bool = True, skip_rank_math_elementor_update=False, restart_docker=False, mirror_assets=False,
                          check_db_schema: bool = False):
        """Run the updater in non-interactive mode"""
        if self.dry_run:
            print("ğŸ” DRY RUN MODE: No changes will be made - showing what would happen")
        
        # Get container
        if self.container_name:
            if self.container_name not in self.get_wp_containers():
                print(f"âŒ Container '{self.container_name}' not found.")
                sys.exit(1)
            selected_container = self.container_name
        else:
            print(f"âŒ Container name is required for non-interactive mode.")
            sys.exit(1)
        
        mode_text = "(non-interactive dry run mode)" if self.dry_run else "(non-interactive mode)"
        print(f"ğŸ¯ Processing container: '{selected_container}' {mode_text}")
        
        # Get working directory
        self.working_dir = self.get_working_directory(selected_container)
        if not self.working_dir:
            sys.exit(1)
        
        print(f"ğŸ“ Working directory: {self.working_dir}")
        
        # Check for updates
        print(f"ğŸ” Checking for available updates...")
        updates = self.get_wp_updates(selected_container, check_elementor_db=not skip_rank_math_elementor_update)

        # --- NEW: Update Rank Math and Elementor plugins first ---
        if updates['plugins'] and not skip_rank_math_elementor_update:
            self.update_rank_math_elementor_plugins(selected_container, updates['plugins'])
        # --- END NEW ---

        # Create backup if requested
        if backup:
            print(f"ğŸ’¾ Creating backup...")
            if not self.backup_site(selected_container, self.working_dir):
                if not self.dry_run:
                    print("âŒ Backup failed. Aborting updates.")
                    sys.exit(1)
        
        # Update core
        if update_core and updates['core']:
            print(f"ğŸ”„ Updating WordPress core...")
            self.update_wordpress_core(selected_container)
        elif update_core and not updates['core']:
            print(f"âœ… WordPress core is already up to date")
        
        # Update plugins
        if update_plugins and updates['plugins']:
            print(f"ğŸ”„ Updating plugins...")
            selected_plugins = self.parse_selection(update_plugins, len(updates['plugins']))
            if selected_plugins:
                self.update_plugins(selected_container, updates['plugins'], selected_plugins)
        elif update_plugins and not updates['plugins']:
            print(f"âœ… All plugins are already up to date")
        
        # Update themes
        if update_themes and updates['themes']:
            print(f"ğŸ”„ Updating themes...")
            selected_themes = self.parse_selection(update_themes, len(updates['themes']))
            if selected_themes:
                self.update_themes(selected_container, updates['themes'], selected_themes)
        elif update_themes and not updates['themes']:
            print(f"âœ… All themes are already up to date")
        
        # Update DB schema
        if check_db_schema:
            print(f"ğŸ”„ Checking/updating database schema...")
            self.update_db_schema(selected_container)

        if self.dry_run:
            self.print_dry_run_summary(selected_container, updates, update_core, 
                                     update_plugins, update_themes, backup,
                                     check_db_schema=check_db_schema)
        else:
            print(f"âœ… Non-interactive update process completed for '{selected_container}'")
            if mirror_assets:
                self.mirror_wp_assets(selected_container)
            if restart_docker:
                self.restart_docker_compose(self.working_dir)

    def restart_docker_compose(self, working_dir: str):
        """Restart docker-compose stack."""
        print(f"ğŸ”„ Restarting docker-compose stack in '{working_dir}'...")
        try:
            # Change to the working directory
            os.chdir(working_dir)
            # Restart the stack
            result = subprocess.run(['docker-compose', 'down'], capture_output=True, text=True)
            if result.returncode != 0:
                print(f"  âŒ Error stopping containers: {result.stderr}")
            result = subprocess.run(['docker-compose', 'up', '-d'], capture_output=True, text=True)
            if result.returncode != 0:
                print(f"  âŒ Error starting containers: {result.stderr}")
            print(f"  âœ… Docker-compose stack restarted successfully")
            logging.info(f"Docker compose restart task completed successfully at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        except Exception as e:
            print(f"  âŒ Error restarting docker-compose: {e}")
        finally:
            # Change back to the original directory
            os.chdir(os.path.dirname(os.path.abspath(__file__)))

    def _generate_inventory(self, container_name: str, asset_type: str) -> Optional[list]:
        """Helper to get a JSON list of plugins or themes from the container."""
        self.log(f"    Generating internal inventory for {asset_type}s...", logging.DEBUG)
        cmd = ['wp', '--allow-root', asset_type, 'list', '--format=json']
        # Run wp-cli commands from the standard WP directory
        docker_options = ['--workdir', '/var/www/html']
        result = self.docker_exec(container_name, cmd, docker_opts=docker_options)
        if result.returncode == 0 and result.stdout:
            try:
                return json.loads(result.stdout)
            except json.JSONDecodeError:
                self.log(f"Failed to parse {asset_type} inventory JSON.", logging.ERROR)
                return None
        else:
            self.log(f"Failed to generate inventory for {asset_type}s from container '{container_name}'.", logging.ERROR)
            self.log(f"Stderr: {result.stderr}", logging.DEBUG)
            return None

    def mirror_wp_assets(self, container_name: str):
        """
        Mirrors plugins and themes from a Docker container to the host by calling an external script.
        """
        print("\n" + "-"*50)
        print(f"ğŸ”— Mirroring WP assets for container: '{container_name}'")

        script_path = "/var/opt/scripts/mirror-wp-assets.sh"

        if not os.path.exists(script_path):
            self.log(f"Asset mirroring script not found at '{script_path}'. Skipping step.", logging.WARNING)
            return

        if self.dry_run:
            print(f"  ğŸ” DRY RUN: Would execute asset mirroring script for '{container_name}'.")
            print(f"  ğŸ” DRY RUN: Would run command: {script_path} --include {container_name}")
            return

        try:
            cmd = [script_path, '--include', container_name]
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            self.log(f"Successfully mirrored assets for '{container_name}'.", logging.INFO)
            logging.info(f"WP assets mirroring task completed successfully at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            if result.stdout:
                self.log(f"Script output:\n{result.stdout}", logging.DEBUG)
        except FileNotFoundError:
            self.log(f"Error: The script '{script_path}' was not found.", logging.ERROR)
        except subprocess.CalledProcessError as e:
            self.log(f"Error during asset mirroring for '{container_name}':", logging.ERROR)
            self.log(f"  Return Code: {e.returncode}", logging.ERROR)
            self.log(f"  Output:\n{e.stdout}", logging.ERROR)
            self.log(f"  Error Output:\n{e.stderr}", logging.ERROR)
        except Exception as e:
            self.log(f"An unexpected error occurred: {e}", logging.ERROR)
        finally:
            print("-" * 50)


def parse_container_names_arg(arg) -> list:
    """Parse --container-names argument from file, pipebar, or stdin, supporting both | and \\n delimiters."""
    containers = []
    if arg == "-":
        # Read from stdin, split on both | and \n
        input_text = sys.stdin.read()
        containers = [c.strip() for c in re.split(r'[|\n\r]+', input_text) if c.strip()]
    elif os.path.isfile(arg):
        # Read from file, split on both | and \n
        with open(arg, "r") as f:
            file_text = f.read()
            containers = [c.strip() for c in re.split(r'[|\n\r]+', file_text) if c.strip()]
    else:
        # Assume pipebar-delimited string
        containers = [c.strip() for c in arg.strip().split('|') if c.strip()]
    return containers
	
def main():
    parser = argparse.ArgumentParser(description='WordPress Docker Container Updater')
    parser.add_argument('--container-name', '-c', help='Target specific container name')
    parser.add_argument('--container-names', help='Multiple containers: file, pipebar string, or "-" for stdin')
    parser.add_argument('--all-containers', action='store_true', help='Update all wp_ containers')
    parser.add_argument('--non-interactive', '-n', action='store_true', 
                       help='Run in non-interactive mode')
    parser.add_argument('--update-core', action='store_true', 
                       help='Update WordPress core (non-interactive mode)')
    parser.add_argument('--update-plugins', '-p', 
                       help='Update plugins: all, none, 1,3,5, 1-5, or plugin-slug')
    parser.add_argument('--update-themes', '-t', 
                       help='Update themes: all, none, 1,3,5, 1-5, or theme-slug')
    parser.add_argument('--no-backup', action='store_true', 
                       help='Skip backup creation (non-interactive mode)')
    parser.add_argument('--dry-run', action='store_true',
                       help='Show what would be done without making any changes')
    parser.add_argument('--restart-docker', action='store_true',
                       help='Restart the docker-compose stack after updates are complete.')
    parser.add_argument('--mirror-wp-assets', action='store_true',
                       help='Mirror plugins and themes from container to host after updates.')
    parser.add_argument('--verbose', '-v', action='store_true', help='Increase output verbosity')
    parser.add_argument('--delete-tarballs-in-container', action='store_true',
                       help='Delete any existing tarballs in the container directory before backup')
    parser.add_argument('--skip-backups', action='store_true',
                        help='Skip all backup creation steps')
    parser.add_argument('--skip-rank-math-elementor-update', action='store_true',
                        help='Skip updates for Rank Math and Elementor plugins')
    parser.add_argument('--check-update-db-schema', action='store_true',
                       help='Run `wp core update-db` to check for and apply database schema updates.')
    parser.add_argument('--rotate-logs', action='store_true',
                       help='Enable log rotation with sensible defaults')
    parser.add_argument('--log-config', 
                       help='Path to YAML config file for custom log rotation settings')
    parser.add_argument('--print-rotate-log-yaml', action='store_true',
                       help='Print default rotate-log YAML template and exit')

    args = parser.parse_args()

    if args.print_rotate_log_yaml:
        print_default_log_config_yaml()
        sys.exit(0)

    # If a log config is provided, treat it as enabling file logging even if --rotate-logs
    # wasn't explicitly passed.
    if args.log_config and not args.rotate_logs:
        args.rotate_logs = True

    setup_log_rotation(rotate_logs=args.rotate_logs, config_path=args.log_config)
    
    # Validate non-interactive mode requirements
    if args.non_interactive and not args.dry_run and not args.all_containers:
        if not args.container_name:
            print(f"âŒ --container-name is required for non-interactive mode")
            sys.exit(1)
        if not any([args.update_core, args.update_plugins, args.update_themes, args.check_update_db_schema]):
            print("âŒ At least one update option must be specified for non-interactive mode")
            sys.exit(1)

    # For dry run without explicit non-interactive flag, suggest using proper flags
    if args.dry_run and not args.non_interactive and not sys.stdin.isatty():
        print("ğŸ” Detected non-interactive environment with --dry-run")
        if not args.container_name and not args.all_containers:
            print("ğŸ’¡ Tip: Use --container-name or --all-containers for non-interactive dry runs")
        if not any([args.update_core, args.update_plugins, args.update_themes, args.check_update_db_schema]):
            print("ğŸ’¡ Tip: Use --update-core, --update-plugins, --update-themes, and/or --check-update-db-schema to specify what to update")

    # Handle --all-containers
    if args.all_containers:
        updater = WordPressUpdater(dry_run=args.dry_run)
        containers = updater.get_wp_containers()
        if not containers:
            print("âŒ No WordPress Docker containers found with 'wp_' prefix.")
            sys.exit(1)
        for container in containers:
            print(f"\n{'='*80}\nProcessing container: {container}\n{'='*80}")
            updater.container_name = container
            updater.working_dir = None  # Reset working dir for each container
            if args.non_interactive:
                updater.run_non_interactive(
                    update_core=args.update_core,
                    update_plugins=args.update_plugins,
                    update_themes=args.update_themes,
                    backup=not (args.no_backup or args.skip_backups),
                    skip_rank_math_elementor_update=args.skip_rank_math_elementor_update,
                    restart_docker=args.restart_docker,
                    mirror_assets=args.mirror_wp_assets,
                    check_db_schema=args.check_update_db_schema
                )
            else:
                updater.run_interactive(
                    skip_rank_math_elementor_update=args.skip_rank_math_elementor_update,
                    restart_docker=args.restart_docker,
                    mirror_assets=args.mirror_wp_assets,
                    check_db_schema=args.check_update_db_schema
                )
        print("\nâœ… All containers processed.")
        sys.exit(0)

    # Handle --container-names
    if args.container_names:
        containers = parse_container_names_arg(args.container_names)
        if not containers:
            print("âŒ No containers found from --container-names input.")
            sys.exit(1)
        updater = WordPressUpdater(dry_run=args.dry_run)
        for container in containers:
            print(f"\n{'='*80}\nProcessing container: {container}\n{'='*80}")
            updater.container_name = container
            updater.working_dir = None  # Reset working dir for each container
            if args.non_interactive:
                updater.run_non_interactive(
                    update_core=args.update_core,
                    update_plugins=args.update_plugins,
                    update_themes=args.update_themes,
                    backup=not (args.no_backup or args.skip_backups),
                    skip_rank_math_elementor_update=args.skip_rank_math_elementor_update,
                    restart_docker=args.restart_docker,
                    mirror_assets=args.mirror_wp_assets,
                    check_db_schema=args.check_update_db_schema
                )
            else:
                updater.run_interactive(
                    skip_rank_math_elementor_update=args.skip_rank_math_elementor_update,
                    restart_docker=args.restart_docker,
                    mirror_assets=args.mirror_wp_assets,
                    check_db_schema=args.check_update_db_schema
                )
        print("\nâœ… All specified containers processed.")
        sys.exit(0)

    # Single container logic
    updater = WordPressUpdater(args.container_name, args.dry_run, verbose=args.verbose)
    if args.non_interactive:
        updater.run_non_interactive(
            update_core=args.update_core,
            update_plugins=args.update_plugins,
            update_themes=args.update_themes,
            backup=not (args.no_backup or args.skip_backups),
            skip_rank_math_elementor_update=args.skip_rank_math_elementor_update,
            restart_docker=args.restart_docker,
            mirror_assets=args.mirror_wp_assets,
            check_db_schema=args.check_update_db_schema
        )
    else:
        updater.run_interactive(
            skip_rank_math_elementor_update=args.skip_rank_math_elementor_update,
            restart_docker=args.restart_docker,
            mirror_assets=args.mirror_wp_assets,
            check_db_schema=args.check_update_db_schema
        )

if __name__ == "__main__":
    main()