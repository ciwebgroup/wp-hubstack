import argparse
import paramiko
import requests
import json
import re
import datetime
import subprocess
from typing import Optional, List, Dict, Any, Tuple
from tabulate import tabulate

class RemoteWPScanner:
    def __init__(self, hostname: Optional[str] = None, username: Optional[str] = None, key_path: Optional[str] = None, 
                 port: int = 22, password: Optional[str] = None, quarantine: bool = False, dry_run: bool = False,
                 container_pattern: str = "wp_", include_containers: Optional[List[str]] = None, exclude_containers: Optional[List[str]] = None,
                 include_assets: Optional[List[str]] = None, exclude_assets: Optional[List[str]] = None, local: bool = False, summary: bool = False) -> None:
        self.hostname: Optional[str] = hostname
        self.username: Optional[str] = username
        self.port: int = port
        self.key_path: Optional[str] = key_path
        self.password: Optional[str] = password
        self.quarantine_mode: bool = quarantine
        self.dry_run: bool = dry_run
        self.local_mode: bool = local
        self.summary_mode: bool = summary
        
        # Filters
        self.container_pattern: str = container_pattern
        self.include_containers: List[str] = include_containers or []
        self.exclude_containers: List[str] = exclude_containers or []
        self.include_assets: List[str] = include_assets or []
        self.exclude_assets: List[str] = exclude_assets or []
        
        self.ssh_client: Optional[paramiko.SSHClient] = None
        self.base_api_url: str = "https://www.wpvulnerability.net"

    def connect(self) -> None:
        """Establishes an SSH connection to the remote server or validates local Docker access."""
        if self.local_mode:
            try:
                subprocess.run(['docker', 'ps'], capture_output=True, check=True)
                print(f"âœ… Local Docker access confirmed")
            except Exception as e:
                print(f"âŒ Failed to access local Docker: {e}")
                raise
        else:
            self.ssh_client = paramiko.SSHClient()
            self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            try:
                # Try to load the key - support multiple key types
                pkey = None
                if self.key_path:
                    try:
                        pkey = paramiko.Ed25519Key.from_private_key_file(self.key_path, password=self.password)
                    except paramiko.ssh_exception.SSHException:
                        try:
                            pkey = paramiko.RSAKey.from_private_key_file(self.key_path, password=self.password)
                        except paramiko.ssh_exception.SSHException:
                            try:
                                pkey = paramiko.ECDSAKey.from_private_key_file(self.key_path, password=self.password)
                            except paramiko.ssh_exception.SSHException:
                                pass  # Will try password auth if available
                
                self.ssh_client.connect(
                    hostname=self.hostname,
                    username=self.username,
                    pkey=pkey,
                    port=self.port,
                    password=self.password
                )
                print(f"âœ… Connected to {self.username}@{self.hostname}")
            except Exception as e:
                print(f"âŒ Failed to connect: {e}")
                raise

    def execute_command(self, command: str) -> Tuple[str, str]:
        """Executes a command on the remote server or locally."""
        if self.local_mode:
            result = subprocess.run(command, shell=True, capture_output=True, text=True)
            return result.stdout.strip(), result.stderr.strip()
        else:
            stdin, stdout, stderr = self.ssh_client.exec_command(command)
            return stdout.read().decode().strip(), stderr.read().decode().strip()

    def find_wordpress_containers(self) -> List[str]:
        """Finds running containers based on filters and wp-config.php presence."""
        cmd = "docker ps --format '{{.Names}}'"
        output, err = self.execute_command(cmd)
        
        candidates = output.split('\n')
        wp_containers = []

        print(f"ğŸ” Scanning container list...")

        for container in candidates:
            container = container.strip()
            if not container: continue

            # --- Filter Logic ---
            # 1. Exclude List (Explicit blacklist)
            if container in self.exclude_containers:
                continue
            
            # 2. Include List (Explicit whitelist overrides pattern)
            if self.include_containers:
                if container not in self.include_containers:
                    continue
            else:
                # 3. Regex Pattern (Only if no include list)
                if not re.search(self.container_pattern, container):
                    continue

            # --- Verification ---
            # Check if wp-config.php exists
            check_cmd = f"docker exec {container} test -f /var/www/html/wp-config.php && echo 'found'"
            try:
                out, err = self.execute_command(check_cmd)
                if out == 'found':
                    wp_containers.append(container)
                else:
                    print(f"   âš ï¸ {container}: wp-config.php not found (stderr: {err})")
            except Exception as e:
                print(f"   âš ï¸ {container}: Failed to verify - {e}")
        
        return wp_containers

    def get_assets(self, container: str, asset_type: str = "plugin") -> Dict[str, str]:
        """Extracts list of plugins or themes."""
        assets = {}
        folder = "plugins" if asset_type == "plugin" else "themes"
        cli_type = "plugin" if asset_type == "plugin" else "theme"
        
        # Method 1: Try WP-CLI
        cmd_wp_cli = f"docker exec {container} wp {cli_type} list --format=json --allow-root 2>/dev/null"
        out, _ = self.execute_command(cmd_wp_cli)
        
        if out and out.startswith('['):
            try:
                data = json.loads(out)
                for item in data:
                    assets[item['name']] = item['version']
                return assets
            except:
                pass

        # Method 2: Filesystem Fallback
        cmd_ls = f"docker exec {container} ls /var/www/html/wp-content/{folder}"
        out_ls, _ = self.execute_command(cmd_ls)
        
        slugs = [s.strip() for s in out_ls.split('\n') if s.strip() and '.' not in s]
        
        for slug in slugs:
            # Look for Version header in PHP files
            grep_cmd = f"docker exec {container} grep -r 'Version:' /var/www/html/wp-content/{folder}/{slug} --include='*.php' | head -n 1"
            out_grep, _ = self.execute_command(grep_cmd)
            
            version_match = re.search(r"Version:\s*([0-9.]+)", out_grep, re.IGNORECASE)
            if version_match:
                assets[slug] = version_match.group(1)
            else:
                assets[slug] = "unknown"
                
        return assets

    def quarantine_asset(self, container: str, slug: str, asset_type: str) -> None:
        """Deactivates, archives, and removes a vulnerable asset."""
        action_prefix = "[DRY RUN]" if self.dry_run else "[ACTION]"
        print(f"   ğŸ›¡ï¸ {action_prefix} Quarantining {asset_type}: {slug}...")
        
        folder = "plugins" if asset_type == "plugin" else "themes"
        wp_content = "/var/www/html/wp-content"
        asset_path = f"{wp_content}/{folder}/{slug}"
        quarantine_dir = f"{wp_content}/quarantined-assets"
        timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
        archive_name = f"{slug}-{asset_type}_{timestamp}.tar.gz"
        archive_path = f"{quarantine_dir}/{archive_name}"

        cmds = []
        # 1. Create Quarantine Dir
        cmds.append(f"mkdir -p {quarantine_dir}")
        
        # 2. Deactivate (Best effort via WP-CLI)
        cmds.append(f"wp {asset_type} deactivate {slug} --allow-root")

        # 3. Archive
        # tar -czf target source
        cmds.append(f"tar -czf {archive_path} -C {wp_content}/{folder} {slug}")

        # 4. Remove
        cmds.append(f"rm -rf {asset_path}")

        if self.dry_run:
            print(f"      Would execute in {container}:")
            for c in cmds:
                print(f"      - docker exec {container} {c}")
        else:
            # Create dir
            self.execute_command(f"docker exec {container} mkdir -p {quarantine_dir}")
            
            # Deactivate (ignore errors)
            self.execute_command(f"docker exec {container} wp {asset_type} deactivate {slug} --allow-root 2>/dev/null")
            
            # Archive
            tar_cmd = f"docker exec {container} tar -czf {archive_path} -C {wp_content}/{folder} {slug}"
            out, err = self.execute_command(tar_cmd)
            
            if err and "No such file" in err:
                print(f"      âŒ Could not find asset directory to quarantine.")
                return

            # Remove
            self.execute_command(f"docker exec {container} rm -rf {asset_path}")
            print(f"      âœ… Quarantined to: {archive_path}")

    def check_vulnerability(self, slug: str, version: str, asset_type: str) -> Any:
        """Queries WPVulnerability API."""
        if version == "unknown":
            return None

        # API supports /plugin/slug and /theme/slug
        endpoint = "plugin" if asset_type == "plugin" else "theme"
        url = f"{self.base_api_url}/{endpoint}/{slug}"
        
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 404:
                return None
            if response.status_code != 200:
                return {"error": f"HTTP {response.status_code}"}

            data = response.json()
            
            vulnerabilities = data.get('data', {}).get('vulnerability', [])

            # Handle null (no vulnerabilities found)
            if vulnerabilities is None:
                return None

            if not isinstance(vulnerabilities, list):
                print(f"      [DEBUG] Unexpected vulnerability type for {slug}: {type(vulnerabilities).__name__}")
                return {"error": f"Unexpected vulnerability format - got {type(vulnerabilities).__name__}: {vulnerabilities}"}

            found_vulns: List[Dict[str, Any]] = []
            for vuln in vulnerabilities:
                if not isinstance(vuln, dict):
                    print(f"   âš ï¸ Unexpected vuln item type for {slug}: {type(vuln)}")
                    continue

                operator = vuln.get('operator', {})
                fixed_in = None
                if isinstance(operator, dict):
                    fixed_in = operator.get('max_version')

                if fixed_in and self.compare_versions(version, fixed_in) < 0:
                    found_vulns.append(vuln)
                elif not fixed_in:
                    found_vulns.append(vuln)

            return found_vulns if found_vulns else None

        except Exception as e:
            return {"error": str(e)}

    def compare_versions(self, current: str, fixed: str) -> int:
        def normalize(v: str) -> List[int]:
            return [int(x) for x in re.sub(r'[^0-9.]', '', v).split('.') if x.isdigit()]
        return (normalize(current) > normalize(fixed)) - (normalize(current) < normalize(fixed))

    def run(self) -> None:
        """Main execution method that scans containers for vulnerabilities."""
        self.connect()
        containers = self.find_wordpress_containers()
        
        if not containers:
            print("No matching WordPress containers found.")
            return

        print(f"ğŸ“¦ Found {len(containers)} containers to scan: {', '.join(containers)}")
        
        # Track vulnerabilities grouped by container and asset
        vuln_summary: Dict[str, Dict[str, List[Dict[str, Any]]]] = {}

        for container in containers:
            print(f"\n--- Analyzing {container} ---")
            
            for asset_type in ['plugin', 'theme']:
                assets = self.get_assets(container, asset_type)
                print(f"   Found {len(assets)} {asset_type}s.")
                
                quarantined_this_run = set()

                for slug, version in assets.items():
                    # --- Asset Filter Logic ---
                    if self.exclude_assets and slug in self.exclude_assets:
                        continue
                    if self.include_assets and slug not in self.include_assets:
                        continue
                    
                    # Check Vuln
                    vulns = self.check_vulnerability(slug, version, asset_type)

                    if isinstance(vulns, list) and vulns:
                        # Initialize container entry if needed
                        if container not in vuln_summary:
                            vuln_summary[container] = {}
                        
                        # Store vulnerabilities for this asset
                        asset_key = f"{asset_type}:{slug}"
                        vuln_summary[container][asset_key] = {
                            'type': asset_type,
                            'slug': slug,
                            'version': version,
                            'vulns': vulns
                        }

                        # Quarantine
                        if self.quarantine_mode and slug not in quarantined_this_run:
                            self.quarantine_asset(container, slug, asset_type)
                            quarantined_this_run.add(slug)

                    elif isinstance(vulns, dict) and 'error' in vulns:
                        print(f"   âš ï¸ Error checking {slug}: {vulns['error']}")
                    elif vulns is None:
                        # No vulnerabilities
                        pass
                    else:
                        print(f"   âš ï¸ Unexpected response type for {slug}: {type(vulns)}")

        # Close SSH client only if remote mode
        if not self.local_mode and self.ssh_client:
            self.ssh_client.close()
        
        # Display results
        if vuln_summary:
            print("\nğŸš¨ VULNERABILITIES FOUND ğŸš¨\n")
            
            if self.summary_mode:
                # Summary view: grouped by container
                summary_table = []
                for container, assets in vuln_summary.items():
                    for asset_key, asset_data in assets.items():
                        vuln_count = len(asset_data['vulns'])
                        summary_table.append([
                            container,
                            asset_data['type'].upper(),
                            asset_data['slug'],
                            asset_data['version'],
                            f"{vuln_count} vulnerabilities"
                        ])
                print(tabulate(summary_table, headers=["Container", "Type", "Asset", "Version", "Vulnerabilities"], tablefmt="grid"))
                print("\nğŸ’¡ Run without --summary flag to see detailed vulnerability information.")
            else:
                # Detailed view: show each vulnerability
                for container, assets in vuln_summary.items():
                    print(f"\nğŸ“¦ {container}")
                    print("=" * 80)
                    
                    for asset_key, asset_data in assets.items():
                        vulns = asset_data['vulns']
                        print(f"\n  ğŸ”´ {asset_data['type'].upper()}: {asset_data['slug']} (v{asset_data['version']})")
                        print(f"  Found {len(vulns)} vulnerabilities:\n")
                        
                        for i, v in enumerate(vulns, 1):
                            if not isinstance(v, dict):
                                continue
                            
                            name = v.get('name', 'Unknown Vulnerability')
                            sources = v.get('source', [])
                            link = 'No URL'
                            if isinstance(sources, list) and sources:
                                first_source = sources[0]
                                if isinstance(first_source, dict):
                                    link = first_source.get('link', 'No URL')
                            
                            print(f"    {i}. {name}")
                            print(f"       ğŸ”— {link}")
                        print()
        else:
            print("\nâœ… No vulnerabilities found.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Remote Docker WP Vulnerability Scanner')
    parser.add_argument('--host', help='Remote Server Hostname/IP')
    parser.add_argument('--user', help='SSH Username')
    parser.add_argument('--key', default='/root/.ssh/id_rsa', help='Path to Private Key inside container')
    parser.add_argument('--password', help='SSH password or key passphrase')
    
    # Flags
    parser.add_argument('--quarantine', action='store_true', help='Automatically deactivate, zip, and move vulnerable assets')
    parser.add_argument('--dry-run', action='store_true', help='Simulate actions without changes')
    parser.add_argument('--local', action='store_true', help='Scan local Docker containers instead of remote')
    parser.add_argument('--summary', action='store_true', help='Show summary view (grouped by asset) instead of all CVEs')
    
    # Container Filters
    parser.add_argument('--container-name-pattern', default='wp_', help='Pattern for container names (default: wp_)')
    parser.add_argument('--include', nargs='+', dest='include_containers', help='Specific containers to include')
    parser.add_argument('--exclude', nargs='+', dest='exclude_containers', help='Specific containers to exclude')
    
    # Asset Filters
    parser.add_argument('--include-asset', nargs='+', help='Specific plugins/themes to check')
    parser.add_argument('--exclude-asset', nargs='+', help='Specific plugins/themes to ignore')

    args = parser.parse_args()
    
    # Validate required arguments
    if not args.local and (not args.host or not args.user):
        parser.error('--host and --user are required unless --local is specified')
    
    scanner = RemoteWPScanner(
        args.host, args.user, args.key, 
        password=args.password,
        quarantine=args.quarantine, 
        dry_run=args.dry_run,
        container_pattern=args.container_name_pattern,
        include_containers=args.include_containers,
        exclude_containers=args.exclude_containers,
        include_assets=args.include_asset,
        exclude_assets=args.exclude_asset,
        local=args.local,
        summary=args.summary
    )
    scanner.run()